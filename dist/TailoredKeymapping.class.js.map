{"version":3,"sources":["../src/TailoredKeymapping.class.js"],"names":[],"mappings":"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","file":"TailoredKeymapping.class.js","sourcesContent":["import _ from 'lodash'\n\n/**\n * Tailoredkeymapping\n * \tmaps objectKeys per given key2keyPairs\n */\nexport default class Tailoredkeymapping {\n\n\terror(msg) {\n\t\tthrow new Error('[TailoredKeymapping] ' + msg)\n\t}\n\n\tconstructor(keymap) {\n\t\tthis.keymap = keymap\n\t}\n\n\tgetKeymap() {\n\t\treturn this.keymap\n\t}\n\n\tsetKeymap(keymap) {\n\t\tthis.validateKeymap(keymap) // maybe throw error\n\t\tthis.keymap = keymap\n\t\treturn this\n\t}\n\n\tvalidateKeymap(keymap) {\n\t\tlet map = keymap || this.keymap\n\t\tif (!map)\n\t\t\tthis.error('no keymap defined. You can use \\'setkeymap(keymap)\\' set a map after initialisation')\n\t\telse\n\t\t\tif (typeof map !== 'object')\n\t\t\t\tthis.error('invalid typeof keymap. \\'object\\' required!')\n\t\treturn true\n\t}\n\n\tgetKeymapTree(tree) {\n\t\tvar keymapSubtree\n\t\tif (!tree) {\n\t\t\tkeymapSubtree = this.keymap\n\t\t}\n\t\telse if (typeof tree === 'string') {\n\t\t\tif (!!this.keymap[tree] && typeof this.keymap[tree] === 'object' ) {\n\t\t\t\tkeymapSubtree = this.keymap[tree]\n\t\t\t}\n\t\t\telse\n\t\t\t\tthis.error('\\'keymap.' + tree + '\\' not found or invalid')\n\t\t}\n\t\telse if(tree instanceof Array) {\n\t\t\tlet mapInner = tree.reduce((map, subtree, i) => {\n\t\t\t\t\tif (!!map[subtree] && typeof map[subtree] === 'object' ) {\n\t\t\t\t\t\treturn map[subtree]\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet notFound = tree.slice(0, i + 1).join('.')\n\t\t\t\t\t\tthis.error('\\'keymap.' + notFound + '\\' not found or invalid')\n\t\t\t\t\t}\n\t\t\t\t}, this.keymap)\n\t\t\tkeymapSubtree = mapInner\n\t\t}\n\t\telse {\n\t\t\t// true-value && !Array && !string\n\t\t\tthis.error('can\\'t handle keymapTree of type object')\n\t\t}\n\n\t\tthis.setKeymapSubtree(keymapSubtree)\n\t\treturn keymapSubtree\n\t}\n\n\tsetKeymapSubtree(subtree)\t{ this.keymapSubtree = subtree \t}\n\tgetKeymapSubtree()\t\t\t{ return this.keymapSubtree \t}\n\n\tsetOptions(options) {\n\t\tthis.options = _.assign({},\n\t\t\t// merge default options ...\n\t\t\t{onlyMappedVars: false, callback: '', keymapTree: ''},\n\t\t\t// ... with given options || callbackFn\n\t\t\ttypeof options === 'function' ? {'callback' : options} : options\n\t\t)\n\t\treturn this.options\n\t}\n\n\t/**\n\t * MapKeys\n\t * \tmaps objectKeys per given key2keyPairs\n\t *\n\t * @param  {object} data - given data keyValueMap\n\t * @param  {string} type - the subtree of the keymap to use\n\t * @param  {object | function} options|callback\n\t *     @option {string} \tmappingType \t- the subsubtree of the keymap to use - default: 'client'\n\t *     @option {bool} \tonlyMappedVars \t- pass unmapped keys? - default: true\n\t *     @option {function} callback \t\t\t- function to be called after mapping - called with mapped data\n\t *     @return {object} mapped KeyValue pairs\n\t *\n\t */\n\tmap(data, options) { // last argument = options || callback\n\t\t// keymap || error\n\t\tthis.validateKeymap()\n\n\t\t// set up vars\n\t\tlet\t_options \t\t= this.setOptions(options)\n\t\t,\tdataNew \t\t= {}\n\t\t// tbd: check whole keymap(+subtree) on construct\n\t\t,\tmap \t\t\t= this.getKeymapTree(_options.keymapTree)\n\t\t,\tsize \t\t\t= _.size(data)\n\t\t,\tcustomFns \t\t= {}\n\t\t,\tcounter \t\t= 0\n\t\t,\tr\n\n\t\t// process mapping\n\t\t_.each(data, (v, i)=>{\n\t\t\tcounter++\n\n\t\t\tif (map[i]) { // check for newKey\n\t\t\t\tif (typeof map[i] !== 'function') {\n\t\t\t\t\t// use given key\n\t\t\t\t\tdataNew[map[i]] = v\n\t\t\t\t\t// also pass the old key ?\n\t\t\t\t\tif (!_options.onlyMappedVars && dataNew[i] === undefined)\n\t\t\t\t\t\tdataNew[i] = v\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t// add to customFns\n\t\t\t\t\tcustomFns[i] = map[i]\n\t\t\t}\n\t\t\telse // key not found - take old key\n\t\t\t\tif (!_options.onlyMappedVars && dataNew[i] === undefined)\n\t\t\t\t\tdataNew[i] = v\n\n\t\t\t// LAST STEP\n\t\t\tif (counter >= size) {\n\t\t\t\tif (Object.keys(customFns).length) {\n\t\t\t\t\t_.each(customFns, (v, i)=> {\n\t\t\t\t\t\tr = v.apply(this, [dataNew, data])\n\t\t\t\t\t\tif (r instanceof Array) {\n\t\t\t\t\t\t\tdataNew[r[0]] = r[1]\n\t\t\t\t\t\t\tif ( !_options.onlyMappedVars && r[0] !== i)\n\t\t\t\t\t\t\t\tdataNew[i] = r[1]\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t// \treturn should be a value -> use old key\n\t\t\t\t\t\t\tdataNew[i] = r\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\t// console.log(_options)\n\t\t\t\t// callback\n\t\t\t\tif (typeof _options.callback === 'function')\n\t\t\t\t\t_options.callback.apply(this, [dataNew, data])\n\t\t\t}\n\t\t})\n\t\treturn dataNew\n\t};\n\n}\n"]}