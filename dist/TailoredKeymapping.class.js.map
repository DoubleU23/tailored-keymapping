{"version":3,"sources":["../src/TailoredKeymapping.class.js"],"names":[],"mappings":"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","file":"TailoredKeymapping.class.js","sourcesContent":["import _ from 'lodash'\n\n/**\n * Tailoredkeymapping\n * \tmaps objectKeys per given key2keyPairs\n */\nexport default class Tailoredkeymapping {\n\n\terror(msg) {\n\t\tthrow new Error('[TailoredKeymapping] ' + msg)\n\t}\n\n\tconstructor(keymap) {\n\t\tthis.keymap = keymap\n\t}\n\n\tgetKeymap() {\n\t\treturn this.keymap\n\t}\n\n\tsetKeymap(keymap) {\n\t\tthis.validateKeymap(keymap) // maybe throw error\n\t\tthis.keymap = keymap\n\t\treturn this\n\t}\n\n\tvalidateKeymap(keymap) {\n\t\tlet map = keymap || this.keymap\n\t\tif (!map)\n\t\t\tthis.error('no keymap defined. You can use \\'setkeymap(keymap)\\' set a map after initialisation')\n\t\telse\n\t\t\tif (typeof map !== 'object')\n\t\t\t\tthis.error('invalid typeof keymap. \\'object\\' required!')\n\t\treturn true\n\t}\n\n\tgetKeymapTree(tree) {\n\t\tvar keymapSubtree\n\t\tif (!tree) {\n\t\t\tkeymapSubtree = this.keymap\n\t\t}\n\t\telse if (typeof tree === 'string') {\n\t\t\tif (!!this.keymap[tree] && typeof this.keymap[tree] === 'object' ) {\n\t\t\t\tkeymapSubtree = this.keymap[tree]\n\t\t\t}\n\t\t\telse\n\t\t\t\tthis.error('\\'keymap.' + tree + '\\' not found or invalid')\n\t\t}\n\t\telse if(tree instanceof Array) {\n\t\t\tlet mapInner = tree.reduce((map, subtree, i) => {\n\t\t\t\t\tif (!!map[subtree] && typeof map[subtree] === 'object' ) {\n\t\t\t\t\t\treturn map[subtree]\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet notFound = tree.slice(0, i + 1).join('.')\n\t\t\t\t\t\tthis.error('\\'keymap.' + notFound + '\\' not found or invalid')\n\t\t\t\t\t}\n\t\t\t\t}, this.keymap)\n\t\t\tkeymapSubtree = mapInner\n\t\t}\n\t\telse {\n\t\t\t// true-value && !Array && !string\n\t\t\tthis.error('can\\'t handle keymapTree of type object')\n\t\t}\n\n\t\tthis.setKeymapSubtree(keymapSubtree)\n\t\treturn keymapSubtree\n\t}\n\n\tsetKeymapSubtree(subtree)\t{ this.keymapSubtree = subtree \t}\n\tgetKeymapSubtree()\t\t\t{ return this.keymapSubtree \t}\n\n\tsetOptions(options) {\n\t\tthis.options = _.assign({},\n\t\t\t// merge default options ...\n\t\t\t{onlyMappedVars: false, callback: '', keymapTree: ''},\n\t\t\t// ... with given options || callbackFn\n\t\t\ttypeof options === 'function' ? {'callback' : options} : options\n\t\t)\n\t\treturn this.options\n\t}\n\n\t/**\n\t * MapKeys\n\t * \tmaps objectKeys per given key2keyPairs\n\t *\n\t * @param  {object} data - given data keyValueMap\n\t * @param  {string} type - the subtree of the keymap to use\n\t * @param  {object | function} options|callback\n\t *                   @option {string} \tmappingType \t- the subsubtree of the keymap to use - default: 'client'\n\t *                   @option {bool} \tonlyMappedVars \t- pass unmapped keys? - default: true\n\t *                   @option {function} callback \t\t\t- function to be called after mapping - called with mapped data\n\t * @return {object} mapped KeyValue pairs\n\t *\n\t * usage (after initiation):\n\t * \tlet mappedData = keymapping.map(payload['FLAT_STRUCT'], 'user', {\n\t *\t\t'mappingType': 'client'|'server',\n\t *\t\t'onlyMappedVars': true|false, // pass unmapped keys?\n\t *\t\tcallback: (data)=>{return newData}\n\t *\t});\n\t * OR\n\t * \tlet mappedData = keymapping.map(payload['FLAT_STRUCT'], 'user', (data)=>{\n\t *\t\t// callback function\n\t *\t\t// mutate data here after mapping completed\n\t *\t});\n\t */\n\tmap(data, options) { // last argument = options || callback\n\t\t// keymap || error\n\t\tthis.validateKeymap()\n\n\t\t// set up vars\n\t\tlet\t_options \t\t= this.setOptions(options)\n\t\t,\tdataNew \t\t= {}\n\t\t// tbd: check whole keymap(+subtree) on construct\n\t\t,\tmap \t\t\t= this.getKeymapTree(_options.keymapTree)\n\t\t,\tsize \t\t\t= _.size(data)\n\t\t,\tcustomFns \t\t= {}\n\t\t,\tcounter \t\t= 0\n\t\t,\tr\n\n\t\t// process mapping\n\t\t_.each(data, (v, i)=>{\n\t\t\tcounter++\n\n\t\t\tif (map[i]) { // check for newKey\n\t\t\t\tif (typeof map[i] !== 'function') {\n\t\t\t\t\t// use given key\n\t\t\t\t\tdataNew[map[i]] = v\n\t\t\t\t\t// also pass the old key if\n\t\t\t\t\tif (!_options.onlyMappedVars)\n\t\t\t\t\t\tdataNew[i] = v\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t// add to customFns\n\t\t\t\t\tcustomFns[i] = map[i]\n\t\t\t}\n\t\t\telse // key not found - take old key\n\t\t\t\tif (!_options.onlyMappedVars) dataNew[i] = v\n\n\t\t\t// LAST STEP\n\t\t\tif (counter >= size) {\n\t\t\t\tif (Object.keys(customFns).length) {\n\t\t\t\t\t_.each(customFns, (v, i)=>{\n\t\t\t\t\t\tr = v.apply(this, [dataNew])\n\t\t\t\t\t\tif (typeof r === 'object')\n\t\t\t\t\t\t//\treturn is a \"array\" - [key, object]\n\t\t\t\t\t\t\tdataNew[r[0]] = r[1]\n\t\t\t\t\t\telse\n\t\t\t\t\t\t// \treturn should be a value -> use old key\n\t\t\t\t\t\t\tdataNew[i] = r\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\t// callback\n\t\t\t\tif (typeof _options.callback === 'function')\n\t\t\t\t\t_options.callback.apply(this, [dataNew])\n\t\t\t}\n\t\t})\n\t\treturn dataNew\n\t};\n\n}\n"]}