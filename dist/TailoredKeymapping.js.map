{"version":3,"sources":["../src/TailoredKeymapping.class.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;IAEqB;AAEpB,UAFoB,kBAEpB,CAAY,MAAZ,EAAoB;;;wBAFA,oBAEA;;OAgDpB,MAAM,UAAC,IAAD,EAAO,IAAP,EAAa,OAAb,EAAyB;;AAC9B,SAAK,cAAL;;;AAD8B,OAIzB,WAAa,iBAAE,MAAF,CAAS,EAAT;;AAEZ,KAAC,aAAa,QAAb,EAAuB,gBAAgB,KAAhB,EAAuB,UAAU,IAAV,EAFnC;;AAIZ,UAAO,OAAP,KAAmB,UAAnB,GAAgC,EAAC,YAAa,OAAb,EAAjC,GAAyD,OAAzD,CAJD;OAMJ,UAAY,EAAZ;;;AAEA,SAAS,QAAO,MAAK,MAAL,CAAY,CAAZ,EAAP,KAA0B,QAA1B,GAAqC,MAAK,MAAL,CAAY,IAAZ,EAAkB,SAAS,WAAT,CAAvD,GAA+E,MAAK,MAAL,CAAY,IAAZ,CAA/E;OACT,OAAU,iBAAE,IAAF,CAAO,IAAP,CAAV;OACA,YAAc,EAAd;OACA,UAAY,CAAZ;OACA,UAZD;;;AAJ8B,mBAmB9B,CAAE,IAAF,CAAO,IAAP,EAAa,UAAC,CAAD,EAAI,CAAJ,EAAQ;AACpB,cADoB;;AAGpB,QAAI,IAAI,CAAJ,CAAJ,EAAY;;AACX,SAAI,OAAO,IAAI,CAAJ,CAAP,KAAkB,UAAlB;;AAEH,cAAQ,IAAI,CAAJ,CAAR,IAAkB,CAAlB,CAFD;;AAKC,gBAAU,CAAV,IAAe,IAAI,CAAJ,CAAf,CALD;KADD;AASC,SAAI,CAAC,SAAS,cAAT,EAAyB,QAAQ,CAAR,IAAa,CAAb,CAA9B;;;AAZmB,QAehB,WAAW,IAAX,EAAiB;AACpB,SAAI,OAAO,IAAP,CAAY,SAAZ,EAAuB,MAAvB,EAA+B;AAClC,uBAAE,IAAF,CAAO,SAAP,EAAkB,UAAC,CAAD,EAAI,CAAJ,EAAQ;AACzB,WAAI,EAAE,KAAF,QAAc,CAAC,OAAD,CAAd,CAAJ,CADyB;AAEzB,WAAI,QAAO,6CAAP,KAAa,QAAb;;AAEH,gBAAQ,EAAE,CAAF,CAAR,IAAgB,EAAE,CAAF,CAAhB,CAFD;;AAKC,gBAAQ,CAAR,IAAa,CAAb,CALD;OAFiB,CAAlB,CADkC;MAAnC;;AADoB,SAahB,OAAO,SAAS,QAAT,KAAsB,UAA7B,EACH,SAAS,QAAT,CAAkB,KAAlB,QAA8B,CAAC,OAAD,CAA9B,EADD;KAbD;IAfY,CAAb,CAnB8B;AAmD9B,UAAO,OAAP,CAnD8B;GAAzB,CAhDc;;;AAEnB,OAAK,MAAL,GAAc,MAAd,CAFmB;EAApB;;cAFoB;;iCAgBL,QAAQ;AACtB,OAAM,UAAU,UAAU,KAAK,MAAL,CADJ;AAEtB,OAAI,CAAC,OAAD,EACH,KAAK,KAAL,CAAW,2FAAX,EADD,KAGC,IAAI,QAAO,yDAAP,KAAmB,QAAnB,EACH,KAAK,KAAL,CAAW,6CAAX,EADD;AAED,UAAO,IAAP,CAPsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBATV,KAAK;AACjB,SAAM,IAAI,KAAJ,CAAU,0BAA0B,GAA1B,CAAhB,CADiB;;;;yBAIJ,QAAQ;AACrB,QAAK,cAAL,CAAoB,MAApB,EADqB;AAErB,QAAK,MAAL,GAAc,MAAd,CAFqB;;;;QAXF","file":"TailoredKeymapping.js","sourcesContent":["import _ from 'lodash';\n\nexport default class TailoredKeyMapping {\n\n\tconstructor(keyMap) {\n\t\t// could be undefined... validateKeyMap called in this.map\n\t\tthis.keyMap = keyMap;\n\t}\n\n\tstatic error(msg) {\n\t\tthrow new Error('[TailoredKeyMapping] ' + msg);\n\t}\n\n\tstatic setMap(keyMap) {\n\t\tthis.validateKeyMap(keyMap);\n\t\tthis.keyMap = keyMap;\n\t}\n\n\tvalidateKeyMap(keyMap) {\n\t\tconst _keyMap = keyMap || this.keyMap;\n\t\tif (!_keyMap)\n\t\t\tthis.error('no keyMap defined. You can use \\'instance.setMap(keyMap)\\' set a map after initialisation');\n\t\telse\n\t\t\tif (typeof _keyMap !== 'object')\n\t\t\t\tthis.error('invalid typeof keyMap. \\'object\\' required!');\n\t\treturn true;\n\t}\n\n\t/**\n\t * MapKeys\n\t * \tmaps objectKeys per given key2keyPairs\n\t *\n\t * @param  {(flat) object} data - given data keyValueMap\n\t * @param  {string} type - the subtree of the keyMap to use\n\t * @param  {object | function} options|callback\n\t *                   @option {string} \tmappingType \t\t- the subsubtree of the keyMap to use - default: 'client'\n\t *                   @option {bool} \tonlyMappedVars \t- pass unmapped keys? - default: true\n\t *                   @option {funciton} callback \t\t\t- function to be called after mapping - called with mapped data\n\t * @return {object} mapped KeyValue pairs\n\t *\n\t * usage (after initiation):\n\t * \tlet mappedData = keyMapping.map(payload['FLAT_STRUCT'], 'user', {\n\t *\t\t'mappingType': 'client'|'server',\n\t *\t\t'onlyMappedVars': true|false, // pass unmapped keys?\n\t *\t\tcallback: (data)=>{return newData}\n\t *\t});\n\t * OR\n\t * \tlet mappedData = keyMapping.map(payload['FLAT_STRUCT'], 'user', (data)=>{\n\t *\t\t// callback function\n\t *\t\t// mutate data here after mapping completed\n\t *\t});\n\t */\n\tmap = (data, type, options) => { // last argument = options || callback\n\t\tthis.validateKeyMap();\n\n\t\t// set up vars\n\t\tlet \t_options \t\t= _.assign({},\n\t\t\t\t\t\t\t\t// merge default options ...\n\t\t\t\t\t\t\t\t{mappingType: 'client', onlyMappedVars: false, callback: null},\n\t\t\t\t\t\t\t\t// ... with given options || callbackFn\n\t\t\t\t\t\t\t\ttypeof options === 'function' ? {'callback' : options} : options\n\t\t\t),\n\t\t\tdataNew \t\t= {},\n\t\t\t// flat or deep map - use mappingType or not\n\t\t\tmap \t\t\t= typeof this.keyMap[0] === 'object' ? this.keyMap[type][_options.mappingType] : this.keyMap[type],\n\t\t\tsize \t\t\t= _.size(data),\n\t\t\tcustomFns \t\t= {},\n\t\t\tcounter \t\t= 0,\n\t\t\tr;\n\n\t\t// process mapping\n\t\t_.each(data, (v, i)=>{\n\t\t\tcounter++;\n\n\t\t\tif (map[i]) { // check for newKey\n\t\t\t\tif (typeof map[i] !== 'function')\n\t\t\t\t\t// use given key\n\t\t\t\t\tdataNew[map[i]] = v;\n\t\t\t\telse\n\t\t\t\t\t// add to customFns\n\t\t\t\t\tcustomFns[i] = map[i];\n\t\t\t}\n\t\t\telse // key not found - take old key\n\t\t\t\tif (!_options.onlyMappedVars) dataNew[i] = v;\n\n\t\t\t// LAST STEP\n\t\t\tif (counter >= size) {\n\t\t\t\tif (Object.keys(customFns).length) {\n\t\t\t\t\t_.each(customFns, (v, i)=>{\n\t\t\t\t\t\tr = v.apply(this, [dataNew]);\n\t\t\t\t\t\tif (typeof r === 'object')\n\t\t\t\t\t\t//\treturn is a \"array\" - [key, object]\n\t\t\t\t\t\t\tdataNew[r[0]] = r[1];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t// \treturn should be a value -> use old key\n\t\t\t\t\t\t\tdataNew[i] = r;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// callback\n\t\t\t\tif (typeof _options.callback === 'function')\n\t\t\t\t\t_options.callback.apply(this, [dataNew]);\n\t\t\t}\n\t\t});\n\t\treturn dataNew;\n\t};\n\n}\n\n\n\n// atm unused\n// export const getMapArgs = (data, map, onlyMappedVars = false) => {\n// \tconsole.log('calling getMapArgs', data, map, onlyMappedVars);\n// \treturn [\n// \t\tdata,\n// \t\t(v, i) => {\n// \t\t\tconsole.log('mapKeys', v, i);\n// \t\t\tif (!onlyMappedVars) data[i] = v;\n// \t\t\tif (!!map[i]) data[map[i]] = v;\n// \t\t\tconsole.log('[getMapArgs] return ', data);\n// \t\t\treturn data;\n// \t\t}\n// \t];\n// };\n\n// // TBD\n// // use for NESTED objects\n// const mapDeep = (data, type, translateFor) =>\n// \t_.map.apply(_, getMapArgs(data, keyMap[type][translateFor]));\n"]}